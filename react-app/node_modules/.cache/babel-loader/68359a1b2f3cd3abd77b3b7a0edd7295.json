{"ast":null,"code":"var _jsxFileName = \"E:\\\\\\u524D\\u7AEF\\\\advanced\\\\react-foundation\\\\react-app\\\\src\\\\index.js\";\n// 这个React的名字不能改,必须是React\nimport React from 'react';\nimport ReactDOM from 'react-dom'; // 这个是我渲染页面的,暂时不要\n// import App from './App';\n// PWA 他可以让我们通过写网页的形式写一个app应用 引入这个serviceWorker使得用户在第一次访问的时候需要使用网络,第二次就不需要网络了,这个网页就被缓存到浏览器里面了\n// import * as serviceWorker from './serviceWorker';\n// 我在这个里面第一个参数写一个div,他也能把这个div渲染出来\n// 这个React虽然没有用到,但是必须要引入,他代表了一个jsx语法\n// 这个语法形式就是在js文件里面写html标签\n// jsx ==> js + xml(html)\n\nvar div = React.createElement(\"div\", {\n  id: \"demo\",\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 17\n  },\n  __self: this\n}, \"shanshan\", React.createElement(\"span\", {\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 17\n  },\n  __self: this\n}, \"zuimei\")); // 这个jsx会利用bable进行转换,转换成React.createElement(type,props,children...),如果我引入的时候是小写的react,那就不好使了\n// 我这一行和上面那一行代码是等价的\n// let div = React.createElement('div',{id: 'demo'}, 'shanshan', React.createElement('span',null, 'zuimei'));\n// 也就是说这个jsx就是一个语法糖,能让我们简洁的写东西\n// 我后面那一串语法就像上面一样是一个函数,这个函数会有一个返回值放到div这个变量里面,它会返回一个对象\n// 总结一下jsx语法,js + html = React.createElement, 通过这个函数返回一个\n// 我这个render是ReactDOM里面的一个函数,所以我们引入的时候我可以直接通过解构的方式直接引入render函数\n// import {render} from 'react-dom';\n// 就可以直接render()这样来写了\n// 第一个参数是我要接受渲染的元素,第二个参数是一个容器,这个容器就是我选到index.html里面的id为root的标签\n\nReactDOM.render(div, document.getElementById('root')); // 使用serviceWorker\n// serviceWorker.unregister();","map":{"version":3,"sources":["E:\\前端\\advanced\\react-foundation\\react-app\\src\\index.js"],"names":["React","ReactDOM","div","render","document","getElementById"],"mappings":";AAAA;AACA,OAAOA,KAAP,MAAkB,OAAlB;AAEA,OAAOC,QAAP,MAAqB,WAArB,C,CAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;AACA,IAAIC,GAAG,GAAG;AAAK,EAAA,EAAE,EAAC,MAAR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAvB,CAAV,C,CACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AAEA;;AACAD,QAAQ,CAACE,MAAT,CAAgBD,GAAhB,EAAqBE,QAAQ,CAACC,cAAT,CAAwB,MAAxB,CAArB,E,CAEA;AACA","sourcesContent":["// 这个React的名字不能改,必须是React\nimport React from 'react';\n\nimport ReactDOM from 'react-dom';\n\n// 这个是我渲染页面的,暂时不要\n// import App from './App';\n\n// PWA 他可以让我们通过写网页的形式写一个app应用 引入这个serviceWorker使得用户在第一次访问的时候需要使用网络,第二次就不需要网络了,这个网页就被缓存到浏览器里面了\n// import * as serviceWorker from './serviceWorker';\n\n// 我在这个里面第一个参数写一个div,他也能把这个div渲染出来\n\n// 这个React虽然没有用到,但是必须要引入,他代表了一个jsx语法\n// 这个语法形式就是在js文件里面写html标签\n// jsx ==> js + xml(html)\nlet div = <div id='demo'>shanshan<span>zuimei</span></div>;\n// 这个jsx会利用bable进行转换,转换成React.createElement(type,props,children...),如果我引入的时候是小写的react,那就不好使了\n\n// 我这一行和上面那一行代码是等价的\n// let div = React.createElement('div',{id: 'demo'}, 'shanshan', React.createElement('span',null, 'zuimei'));\n// 也就是说这个jsx就是一个语法糖,能让我们简洁的写东西\n\n// 我后面那一串语法就像上面一样是一个函数,这个函数会有一个返回值放到div这个变量里面,它会返回一个对象\n\n// 总结一下jsx语法,js + html = React.createElement, 通过这个函数返回一个\n\n\n// 我这个render是ReactDOM里面的一个函数,所以我们引入的时候我可以直接通过解构的方式直接引入render函数\n// import {render} from 'react-dom';\n// 就可以直接render()这样来写了\n\n// 第一个参数是我要接受渲染的元素,第二个参数是一个容器,这个容器就是我选到index.html里面的id为root的标签\nReactDOM.render(div, document.getElementById('root'));\n\n// 使用serviceWorker\n// serviceWorker.unregister();\n"]},"metadata":{},"sourceType":"module"}